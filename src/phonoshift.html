<!doctype html>
<!-- PhonoShift v1.0 demo - ROT500K family - github.com/syhunt/kanashift -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ROT500K Family / PhonoShift — Local Demo</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>ROT500K Family (aka <em>PhonoShift</em>) — Offline Demo</h1>

  <p>
    <strong>PhonoShift (ROT500K)</strong> is a keyed, format-preserving obfuscation scheme that applies polyalphabetic,
    class-preserving rotations driven by a PBKDF2-HMAC keystream. The default configuration uses
    <strong>500,000 PBKDF2 iterations</strong>, from which the “500K” name originates.
  </p>

  <div class="tabs">
    <button class="tabbtn active" data-tab="demo">Demo</button>
    <button class="tabbtn" data-tab="about">About</button>
  </div>

  <div id="demo" class="panel active">
    <div class="box">
      <div class="row">
        <div class="field">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="ROT500K" selected>ROT500K — base (no length increase)</option>
            <option value="ROT500KV">ROT500KV — verified (auto, increases output)</option>
            <option value="ROT500KT">ROT500KT — token-verified (adds chars per token)</option>
            <option value="ROT500KP">ROT500KP — prefix-verified (adds prefix tag)</option>
          </select>
          <div class="small">
            <span class="pill">ROT500K</span> keeps length.
            <span class="pill">ROT500KV</span> adds verification so decrypt can return true/false.
          </div>
        </div>

        <div class="field">
          <label for="checkChars">Token check chars (ROT500KT / ROT500KV)</label>
          <input id="checkChars" type="number" value="1" min="1" step="1" />
          <div class="small">Higher = lower chance of “false OK” with wrong password.</div>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="shiftPunct">Shift punctuation (optional)</label>
          <label class="small" style="display:flex;gap:10px;align-items:center;">
            <input id="shiftPunct" type="checkbox" checked />
            Swap punctuation glyphs within role-sets (reversible). Does not move punctuation positions.
            <span style="opacity:.8">(Only ¿¡ and !?)</span>
          </label>
        </div>
      </div>

      <div class="row">
        <div class="field" style="flex: 1 1 100%;">
          <label for="name">Input (plaintext or obfuscated)</label>
          <textarea id="name" rows="4">Vamos lá, ver se isso funciona mesmo!</textarea>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="password">Password</label>
          <input id="password" value="correct horse battery staple" />
        </div>
        <div class="field">
          <label for="iterations">PBKDF2 iterations</label>
          <input id="iterations" type="number" value="500000" min="1" step="1000" />
        </div>
        <div class="field">
          <label for="salt">Salt</label>
          <input id="salt" value="NameFPE:v1" />
        </div>
      </div>

      <div class="btns">
        <button id="btnEnc">Encode</button>
        <button id="btnDec">Decode</button>
        <button id="btnSwap">Swap ↔</button>
      </div>

      <div class="field">
        <label for="out">Output</label>
        <textarea id="out" readonly rows="4"></textarea>
      </div>

      <div class="note" id="status">
        Tip: Encode writes to Output. Decode reads from Input. In verified modes, Decode can detect wrong parameters.
      </div>
    </div>
  </div>

  <div id="about" class="panel">
    <div class="box">
      <h2 class="h2">About the ROT500K Family</h2>

      <p>
        <strong>ROT500K</strong> keeps the output length identical to the input and preserves separators
        (<code>space</code>, <code>-</code>, <code>'</code>) and character classes (digits remain digits).
        It is fully reversible with the same <em>password + salt + iterations</em>.
      </p>

      <p>
        <strong>ROT500KV</strong> is the “verified” variant. It intentionally increases output slightly to embed
        a keyed verification signal, so decryption can return a definitive <em>true/false</em> result.
        It automatically chooses the most appropriate verification style:
      </p>
      <ul>
        <li><strong>ROT500KT</strong> (token verification): appends 1+ characters per token (stealthy, robust)</li>
        <li><strong>ROT500KP</strong> (prefix verification): adds a short, word-like prefix (best for very short inputs)</li>
      </ul>

      <hr class="hr">

      <h3 class="h3">How does this compare to ROT13?</h3>
      <p>
        ROT13 is a single fixed substitution with no secret — recognizable immediately and reversible with trivial effort.
        ROT500K is keyed and polyalphabetic: the same plaintext character can map to different outputs depending on position,
        and guessing parameters is expensive due to PBKDF2.
      </p>

      <p class="p0">
        <strong>Quick rule:</strong> use <code>ROT500K</code> when you must keep length identical; use <code>ROT500KV</code>
        when you also need decryption to detect wrong parameters.
      </p>

      <p class="small">
        <strong>Punctuation shifting (optional):</strong> Rotates within
        <code>¿ ¡</code> and <code>! ?</code>. It hides “question vs exclamation” while keeping text readable.
      </p>
    </div>
  </div>

  <script>
  (() => {
    const te = new TextEncoder();

    // -----------------------------
    // Core helpers
    // -----------------------------

    function isSeparator(ch) { return ch === " " || ch === "-" || ch === "'"; }

    function isDigit(ch) { return ch >= "0" && ch <= "9"; }
    function isAsciiUpper(ch) { return ch >= "A" && ch <= "Z"; }
    function isAsciiLower(ch) { return ch >= "a" && ch <= "z"; }
    function toLowerASCII(ch) { return isAsciiUpper(ch) ? String.fromCharCode(ch.charCodeAt(0) | 0x20) : ch; }
    function toUpperASCII(ch) { return isAsciiLower(ch) ? String.fromCharCode(ch.charCodeAt(0) & ~0x20) : ch; }

    function indexOfChar(setChars, ch) { return setChars.indexOf(ch); }

    function effectiveShift(shift, setSize) {
      if (setSize <= 1) return 0;
      let m = shift % setSize; // can be negative
      if (m === 0) m = (shift >= 0) ? 1 : -1; // never allow 0-rotation
      return m;
    }

    function rotateInSetNoZero(setChars, ch, shift) {
      const n = setChars.length;
      const idx = setChars.indexOf(ch);
      if (idx < 0) return ch;

      const eff = effectiveShift(shift, n);
      // JS % can be negative, so normalize
      const j = (idx + eff) % n;
      const jj = (j + n) % n;
      return setChars.charAt(jj);
    }

    async function deriveKeyStream(password, salt, iterations, needBytes) {
      if (needBytes < 32) needBytes = 32;
      const pwBytes = te.encode(password);
      const saltBytes = te.encode(salt);

      const baseKey = await crypto.subtle.importKey("raw", pwBytes, "PBKDF2", false, ["deriveBits"]);
      const bits = await crypto.subtle.deriveBits(
        { name: "PBKDF2", hash: "SHA-256", salt: saltBytes, iterations: iterations },
        baseKey,
        needBytes * 8
      );
      return new Uint8Array(bits);
    }

    async function transformNameNameLikeFPE(s, password, iterations, salt, direction) {
      const VOW_LO = "aeiou";
      const CON_LO = "bcdfghjklmnpqrstvwxyz";

      const VOW_LO_PT = "áàâãäéèêëíìîïóòôõöúùûü";
      const VOW_UP_PT = "ÁÀÂÃÄÉÈÊËÍÌÎÏÓÒÔÕÖÚÙÛÜ";

      const CON_LO_PT = "ç";
      const CON_UP_PT = "Ç";

      if (!s) return s;

      const ks = await deriveKeyStream(password, salt, iterations, s.length + 64);
      let kpos = 0;

      let out = "";
      for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);

        if (isSeparator(c)) { out += c; continue; }

        // +1 ensures keystream never produces a 0 shift (and remains invertible because direction flips on decrypt)
        const shift = ((ks[kpos] | 0) + 1) * direction;
        kpos++; if (kpos >= ks.length) kpos = 0;

if (isDigit(c)) {
  const d = c.charCodeAt(0) - 48;
  const nd = (d + (shift % 10) + 10) % 10; // strict, invertible
  out += String.fromCharCode(48 + nd);
  continue;
}

        const upper = isAsciiUpper(c) || (VOW_UP_PT.includes(c) || CON_UP_PT.includes(c));

        let lc = c;
        if (isAsciiUpper(lc)) lc = toLowerASCII(lc);

        if (VOW_LO.includes(lc)) {
          let ch = rotateInSetNoZero(VOW_LO, lc, shift);
          if (upper) ch = toUpperASCII(ch);
          out += ch;
          continue;
        }

        if (CON_LO.includes(lc)) {
          let ch = rotateInSetNoZero(CON_LO, lc, shift);
          if (upper) ch = toUpperASCII(ch);
          out += ch;
          continue;
        }

        if (VOW_LO_PT.includes(c)) { out += rotateInSetNoZero(VOW_LO_PT, c, shift); continue; }
        if (VOW_UP_PT.includes(c)) { out += rotateInSetNoZero(VOW_UP_PT, c, shift); continue; }

        if (CON_LO_PT.includes(c)) { out += rotateInSetNoZero(CON_LO_PT, c, shift); continue; }
        if (CON_UP_PT.includes(c)) { out += rotateInSetNoZero(CON_UP_PT, c, shift); continue; }

        out += c;
      }

      return out;
    }

    // -----------------------------
    // Optional punctuation shifting (only ¿¡ and !?)
    // -----------------------------
    const P_OPEN = "¿¡";
    const P_END  = "!?";

    function isShiftPunct(ch) {
      return P_OPEN.includes(ch) || P_END.includes(ch);
    }

    async function punctShiftApply(s, password, iterations, salt, direction) {
      if (!s) return s;

      let need = 0;
      for (let i = 0; i < s.length; i++) if (isShiftPunct(s.charAt(i))) need++;
      if (need === 0) return s;

      const punctSalt = salt + "|PunctShift:v1";
      const ks = await deriveKeyStream(password, punctSalt, iterations, need + 64);
      let kpos = 0;

      let out = s.split("");
      for (let i = 0; i < out.length; i++) {
        const c = out[i];
        if (!isShiftPunct(c)) continue;

        const shift = ((ks[kpos] | 0) + 1) * direction;
        kpos++; if (kpos >= ks.length) kpos = 0;

        if (P_OPEN.includes(c)) out[i] = rotateInSetNoZero(P_OPEN, c, shift);
        else out[i] = rotateInSetNoZero(P_END, c, shift);
      }

      return out.join("");
    }

    async function ROT500K_Encrypt(name, password, iterations = 500000, salt = "NameFPE:v1", shiftPunctuation = true) {
      let r = await transformNameNameLikeFPE(name, password, iterations, salt, +1);
      if (shiftPunctuation) r = await punctShiftApply(r, password, iterations, salt, +1);
      return r;
    }

    async function ROT500K_Decrypt(obfuscated, password, iterations = 500000, salt = "NameFPE:v1", shiftPunctuation = true) {
      let s = obfuscated;
      if (shiftPunctuation) s = await punctShiftApply(s, password, iterations, salt, -1);
      return transformNameNameLikeFPE(s, password, iterations, salt, -1);
    }

    // -----------------------------
    // HMAC helpers (WebCrypto)
    // -----------------------------
    async function hmacSha256Bytes(keyStr, msgStr) {
      const keyBytes = te.encode(keyStr);
      const msgBytes = te.encode(msgStr);
      const key = await crypto.subtle.importKey("raw", keyBytes, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
      const sig = await crypto.subtle.sign("HMAC", key, msgBytes);
      return new Uint8Array(sig);
    }

    // -----------------------------
    // ROT500KT (token-verified) — match
    // -----------------------------
    function isTokenSep(ch) {
      // IsTokenSep includes: space - ' . , ! ? : ; and \t \n \r
      return (
        ch === " " || ch === "-" || ch === "'" ||
        ch === "." || ch === "," || ch === "!" || ch === "?" ||
        ch === ":" || ch === ";" ||
        ch === "\t" || ch === "\n" || ch === "\r"
      );
    }

    function isAllDigitsStr(s) {
      if (!s) return false;
      for (let i = 0; i < s.length; i++) if (!isDigit(s.charAt(i))) return false;
      return true;
    }

    function isAllUpperASCII(s) {
      let hasLetter = false;
      for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);
        if (c >= "a" && c <= "z") return false;
        if (c >= "A" && c <= "Z") hasLetter = true;
      }
      return hasLetter;
    }

    const CONSET = "bcdfghjklmnpqrstvwxyz";

    async function tokenDigest(password, salt, iterations, tokenIndex, tokenPlain) {
      const msg = `PhonoShiftTok:v1|${salt}|${iterations}|${tokenIndex}|${tokenPlain}`;
      return hmacSha256Bytes(password, msg);
    }

    function makeTokenCheck(tokenPlain, kind, macBytes, checkCharsPerToken) {
      const n = Math.max(1, checkCharsPerToken | 0);
      const upperMode = (kind === "alpha") && isAllUpperASCII(tokenPlain);

      let out = "";
      for (let i = 0; i < n; i++) {
        const b = macBytes[(i * 7) & 31];
        if (kind === "digits") out += String.fromCharCode(48 + (b % 10));
        else {
          let ch = CONSET.charAt(b % CONSET.length);
          if (upperMode) ch = ch.toUpperCase();
          out += ch;
        }
      }
      return out;
    }

    async function buildPlainTokenChecks(plain, password, salt, iterations, checkCharsPerToken) {
      const checks = [];
      let tok = "";
      let tokIdx = 0;

      for (let i = 0; i < plain.length; i++) {
        const c = plain.charAt(i);
        if (isTokenSep(c)) {
          if (tok) {
            const kind = isAllDigitsStr(tok) ? "digits" : "alpha";
            const mac = await tokenDigest(password, salt, iterations, tokIdx, tok);
            checks.push(makeTokenCheck(tok, kind, mac, checkCharsPerToken));
            tokIdx++;
            tok = "";
          }
        } else {
          tok += c;
        }
      }

      if (tok) {
        const kind = isAllDigitsStr(tok) ? "digits" : "alpha";
        const mac = await tokenDigest(password, salt, iterations, tokIdx, tok);
        checks.push(makeTokenCheck(tok, kind, mac, checkCharsPerToken));
      }

      return checks;
    }

    function attachChecksToCipher(cipher, checks) {
      let out = "";
      let tok = "";
      let tokIdx = 0;

      for (let i = 0; i < cipher.length; i++) {
        const c = cipher.charAt(i);
        if (isTokenSep(c)) {
          if (tok) {
            if (tokIdx >= checks.length) throw new Error("ROT500K_TokenTagged: token/check count mismatch.");
            out += tok + checks[tokIdx];
            tokIdx++;
            tok = "";
          }
          out += c;
        } else {
          tok += c;
        }
      }

      if (tok) {
        if (tokIdx >= checks.length) throw new Error("ROT500K_TokenTagged: token/check count mismatch.");
        out += tok + checks[tokIdx];
        tokIdx++;
      }

      if (tokIdx !== checks.length) throw new Error("ROT500K_TokenTagged: unused checks remain.");
      return out;
    }

    function stripChecksFromTagged(tagged, checkCharsPerToken) {
      const n = Math.max(1, checkCharsPerToken | 0);

      let baseCipher = "";
      const givenChecks = [];

      let tok = "";
      for (let i = 0; i < tagged.length; i++) {
        const c = tagged.charAt(i);
        if (isTokenSep(c)) {
          if (tok) {
            if (tok.length <= n) return null;
            const chk = tok.slice(-n);
            const baseTok = tok.slice(0, -n);
            givenChecks.push(chk);
            baseCipher += baseTok;
            tok = "";
          }
          baseCipher += c;
        } else {
          tok += c;
        }
      }

      if (tok) {
        if (tok.length <= n) return null;
        const chk = tok.slice(-n);
        const baseTok = tok.slice(0, -n);
        givenChecks.push(chk);
        baseCipher += baseTok;
      }

      return { baseCipher, givenChecks };
    }

    async function ROT500K_TokenTagged(name, password, iterations = 500000, salt = "NameFPE:v1", checkCharsPerToken = 1, shiftPunctuation = true) {
      const cipher = await transformNameNameLikeFPE(name, password, iterations, salt, +1);

      const checks = await buildPlainTokenChecks(name, password, salt, iterations, checkCharsPerToken);
      let out = attachChecksToCipher(cipher, checks);

      if (shiftPunctuation) out = await punctShiftApply(out, password, iterations, salt, +1);
      return out;
    }

    async function ROT500K_TokenTaggedDecrypt(tagged, password, iterations = 500000, salt = "NameFPE:v1", checkCharsPerToken = 1, shiftPunctuation = true) {
      let s = tagged;
      if (shiftPunctuation) s = await punctShiftApply(s, password, iterations, salt, -1);

      const stripped = stripChecksFromTagged(s, checkCharsPerToken);
      if (!stripped) return { ok: false, value: "" };

      const plain = await transformNameNameLikeFPE(stripped.baseCipher, password, iterations, salt, -1);
      const expected = await buildPlainTokenChecks(plain, password, salt, iterations, checkCharsPerToken);

      if (expected.length !== stripped.givenChecks.length) return { ok: false, value: "" };
      for (let i = 0; i < expected.length; i++) {
        if (expected[i] !== stripped.givenChecks[i]) return { ok: false, value: "" };
      }

      return { ok: true, value: plain };
    }

    // -----------------------------
    // ROT500KP (prefix-verified)
    // -----------------------------
    const ROT500K_TAG_DOMAIN = "PhonoShiftTag:v1";

    function onlyLettersASCIIOrPT(c) {
      const pt = "áàâãäéèêëíìîïóòôõöúùûüÁÀÂÃÄÉÈÊËÍÌÎÏÓÒÔÕÖÚÙÛÜçÇ";
      return (c >= "A" && c <= "Z") || (c >= "a" && c <= "z") || pt.includes(c);
    }

    function detectCaseStyle(plain) {
      let hasLetter = false, anyUpper = false, anyLower = false;

      for (let i = 0; i < plain.length; i++) {
        const c = plain.charAt(i);
        if (!onlyLettersASCIIOrPT(c)) continue;

        hasLetter = true;
        if (c >= "A" && c <= "Z") anyUpper = true;
        else if (c >= "a" && c <= "z") anyLower = true;
        else { anyUpper = true; anyLower = true; }
      }

      if (!hasLetter) return "title";
      if (anyUpper && !anyLower) return "upper";
      if (anyLower && !anyUpper) return "lower";
      return "title";
    }

    function applyCaseStyleToWord(w, style) {
      if (!w) return w;

      if (style === "upper") return w.toUpperCase();
      if (style === "lower") return w.toLowerCase();

      // title: upper first, lower rest (ASCII-ish behavior; good enough for tag words)
      const low = w.toLowerCase();
      return low.charAt(0).toUpperCase() + low.slice(1);
    }

    function applyCaseStyleToPhrase(phrase, style) {
      return phrase.split(" ").map(p => applyCaseStyleToWord(p, style)).join(" ");
    }

    function makePronounceableWordFromBytes(bytes, offset, syllables) {
      const CSet = "bcdfghjklmnpqrstvwxyz";
      const VSet = "aeiou";
      let out = "";
      for (let i = 0; i < syllables; i++) {
        const x = bytes[(offset + i) & 31];
        const cIdx = x % CSet.length;
        const vIdx = Math.floor(x / CSet.length) % VSet.length;
        out += CSet.charAt(cIdx) + VSet.charAt(vIdx);
      }
      return out;
    }

    function pickPunctFromBytes(bytes) {
      // only '? ' or '! '
      const puncts = ["? ", "! "];
      return puncts[bytes[0] % puncts.length];
    }

    async function buildTagPrefixForPlaintext(plain, password, iterations, salt) {
      const msg = `${ROT500K_TAG_DOMAIN}|${salt}|${iterations}|${plain}`;
      const mac = await hmacSha256Bytes(password, msg);

      const w1 = makePronounceableWordFromBytes(mac, 1, 3);
      const w2 = makePronounceableWordFromBytes(mac, 4, 3);
      let phrase = `${w1} ${w2}`;

      const punct = pickPunctFromBytes(mac);
      const style = detectCaseStyle(plain);
      phrase = applyCaseStyleToPhrase(phrase, style);

      return phrase + punct; // ends with space
    }

    function splitTaggedPrefix(tagged) {
      for (let i = 0; i < tagged.length - 1; i++) {
        const c = tagged.charAt(i);
        if ((c === "?" || c === "!") && tagged.charAt(i + 1) === " ") {
          const prefix = tagged.slice(0, i + 1); // includes punct (no space)
          const cipher = tagged.slice(i + 2);    // after "<punct><space>"
          return cipher ? { prefix, cipher } : null;
        }
      }
      return null;
    }

    async function ROT500K_PrefixTagged(name, password, iterations = 500000, salt = "NameFPE:v1", shiftPunctuation = true) {
      const cipher = await transformNameNameLikeFPE(name, password, iterations, salt, +1);
      const prefix = await buildTagPrefixForPlaintext(name, password, iterations, salt);

      let out = prefix + cipher;
      if (shiftPunctuation) out = await punctShiftApply(out, password, iterations, salt, +1);
      return out;
    }

    async function ROT500K_PrefixTaggedDecrypt(tagged, password, iterations = 500000, salt = "NameFPE:v1", shiftPunctuation = true) {
      let s = tagged;
      if (shiftPunctuation) s = await punctShiftApply(s, password, iterations, salt, -1);

      const parsed = splitTaggedPrefix(s);
      if (!parsed) return { ok: false, value: "" };

      const plain = await transformNameNameLikeFPE(parsed.cipher, password, iterations, salt, -1);
      const expected = await buildTagPrefixForPlaintext(plain, password, iterations, salt);

      const expectedPrefixNoSpace = expected.slice(0, expected.length - 1); // remove trailing space
      if (expectedPrefixNoSpace !== parsed.prefix) return { ok: false, value: "" };

      return { ok: true, value: plain };
    }

    // -----------------------------
    // ROT500KV (verified auto-select)
    // -----------------------------
    function containsStructuredDelimiters(s) {
      for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);
        if (c === "{" || c === "}" || c === "[" || c === "]" || c === '"' ||
            c === "\\" || c === "<" || c === ">" || c === "=" || c === ":") {
          return true;
        }
      }
      return false;
    }

    function countTokensSimple(s) {
      let count = 0, inTok = false;
      for (let i = 0; i < s.length; i++) {
        if (isTokenSep(s.charAt(i))) inTok = false;
        else if (!inTok) { count++; inTok = true; }
      }
      return count;
    }

    function minTokenLenSimple(s) {
      let min = Infinity, cur = 0, inTok = false;
      for (let i = 0; i < s.length; i++) {
        const c = s.charAt(i);
        if (isTokenSep(c)) {
          if (inTok) min = Math.min(min, cur);
          cur = 0; inTok = false;
        } else {
          inTok = true; cur++;
        }
      }
      if (inTok) min = Math.min(min, cur);
      return min === Infinity ? 0 : min;
    }

    function shouldUseTokenTagged(plain, checkCharsPerToken) {
      const n = Math.max(1, checkCharsPerToken | 0);

      if (containsStructuredDelimiters(plain)) return false;

      const tokCount = countTokensSimple(plain);
      const minLen = minTokenLenSimple(plain);

      return tokCount >= 2 && minLen > n && plain.length >= 6;
    }

    // Heuristic ciphertext classifier
    function looksLikeRot500KCipher(s, checkCharsPerToken) {
      const N = Math.max(1, checkCharsPerToken | 0);
      if (!s) return false;

      // trim WS
      const trimmed = s.replace(/^[ \t\r\n]+|[ \t\r\n]+$/g, "");
      if (!trimmed) return false;

      function isAsciiLetter(ch) {
        return (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z");
      }

      function isConsonantAscii(ch) {
        const low = (ch >= "A" && ch <= "Z") ? String.fromCharCode(ch.charCodeAt(0) | 0x20) : ch;
        return "bcdfghjklmnpqrstvwxyz".includes(low);
      }

      function looksLikeKpPrefixAtStart(x) {
        let punctPos = 0;
        for (let i = 0; i < x.length - 1 && i <= 48; i++) {
          if ((x[i] === "?" || x[i] === "!") && x[i + 1] === " ") {
            punctPos = i + 1; // 1-based-ish not needed
            // require at least one space before punct
            const a = x.lastIndexOf(" ", i);
            if (a < 0) return false;

            // tag region mostly letters/spaces/-/'
            for (let p = 0; p < i; p++) {
              const ch = x[p];
              if (!isAsciiLetter(ch) && ch !== " " && ch !== "-" && ch !== "'") return false;
            }
            return true;
          }
        }
        return false;
      }

      function looksLikeKtTokenTagged(x) {
        let tok = "";
        let good = 0, total = 0;

        function finishToken() {
          if (!tok) return;
          total++;
          if (tok.length > N) {
            const suf = tok.slice(-N);
            let okDigits = true, okCons = true;
            for (let j = 0; j < suf.length; j++) {
              const ch = suf[j];
              if (!(ch >= "0" && ch <= "9")) okDigits = false;
              if (!isConsonantAscii(ch)) okCons = false;
            }
            if (okDigits || okCons) good++;
          }
        }

        for (let i = 0; i < x.length; i++) {
          const c = x[i];
          if (isTokenSep(c)) { finishToken(); tok = ""; }
          else tok += c;
        }
        finishToken();

        if (total < 2) return false;
        return Math.floor((good * 100) / total) >= 70;
      }

      if (looksLikeKpPrefixAtStart(trimmed)) return true;
      if (looksLikeKtTokenTagged(trimmed)) return true;
      return false;
    }

    async function ROT500KV_SafeEncrypt(name, password, iterations, salt, checkCharsPerToken, shiftPunctuation) {
      if (shouldUseTokenTagged(name, checkCharsPerToken)) {
        return ROT500K_TokenTagged(name, password, iterations, salt, checkCharsPerToken, shiftPunctuation);
      }
      return ROT500K_PrefixTagged(name, password, iterations, salt, shiftPunctuation);
    }

    async function ROT500KV_SafeDecrypt(obfuscated, password, iterations, salt, checkCharsPerToken, shiftPunctuation) {
      const kt = await ROT500K_TokenTaggedDecrypt(obfuscated, password, iterations, salt, checkCharsPerToken, shiftPunctuation);
      if (kt.ok) return kt;

      const kp = await ROT500K_PrefixTaggedDecrypt(obfuscated, password, iterations, salt, shiftPunctuation);
      if (kp.ok) return kp;

      return { ok: false, value: "" };
    }

    async function ROT500KV(name, password, iterations = 500000, salt = "NameFPE:v1", checkCharsPerToken = 1, shiftPunctuation = true) {
      // 0) refuse to double-encrypt: try decrypt first if it looks like ciphertext
      if (looksLikeRot500KCipher(name, checkCharsPerToken)) {
        const r = await ROT500KV_SafeDecrypt(name, password, iterations, salt, checkCharsPerToken, shiftPunctuation);
        if (r.ok) return r.value;
        // else fall through: treat as plaintext and encrypt
      }

      // 1) adaptive hardening for ENCRYPTION only (length-based)
      let eff = Math.max(1, checkCharsPerToken | 0);
      if (name.length < 12) eff = Math.max(eff, 2);
      if (name.length < 6)  eff = Math.max(eff, 3);

      // 2) encrypt
      return ROT500KV_SafeEncrypt(name, password, iterations, salt, eff, shiftPunctuation);
    }

    async function ROT500KV_Decrypt(obfuscated, password, iterations = 500000, salt = "NameFPE:v1", checkCharsPerToken = 1, shiftPunctuation = true) {
      return ROT500KV_SafeDecrypt(obfuscated, password, iterations, salt, checkCharsPerToken, shiftPunctuation);
    }

    // -----------------------------
    // UI wiring
    // -----------------------------
    const $ = (id) => document.getElementById(id);
    const btnEnc = $("btnEnc");
    const btnDec = $("btnDec");
    const btnSwap = $("btnSwap");
    const statusEl = $("status");

    function setBusy(b) {
      btnEnc.disabled = b;
      btnDec.disabled = b;
      btnSwap.disabled = b;
    }

    function status(msg, ok = null) {
      if (ok === true) statusEl.innerHTML = `<span class="ok">${msg}</span>`;
      else if (ok === false) statusEl.innerHTML = `<span class="bad">${msg}</span>`;
      else statusEl.textContent = msg;
    }

    function getParams() {
      const mode = $("mode").value;
      const name = $("name").value;
      const pw = $("password").value;
      const it = Math.max(1, parseInt($("iterations").value || "1", 10));
      const salt = $("salt").value || "NameFPE:v1";
      const cc = Math.max(1, parseInt($("checkChars").value || "1", 10));
      const sp = $("shiftPunct").checked;
      return { mode, name, pw, it, salt, cc, sp };
    }

    async function doEncode() {
      const { mode, name, pw, it, salt, cc, sp } = getParams();
      if (mode === "ROT500K") return ROT500K_Encrypt(name, pw, it, salt, sp);
      if (mode === "ROT500KP") return ROT500K_PrefixTagged(name, pw, it, salt, sp);
      if (mode === "ROT500KT") return ROT500K_TokenTagged(name, pw, it, salt, cc, sp);
      return ROT500KV(name, pw, it, salt, cc, sp);
    }

    async function doDecode() {
      const { mode, name, pw, it, salt, cc, sp } = getParams();
      if (mode === "ROT500K") {
        const dec = await ROT500K_Decrypt(name, pw, it, salt, sp);
        return { ok: true, value: dec, verified: false };
      }
      if (mode === "ROT500KP") {
        const r = await ROT500K_PrefixTaggedDecrypt(name, pw, it, salt, sp);
        return { ok: r.ok, value: r.value, verified: true };
      }
      if (mode === "ROT500KT") {
        const r = await ROT500K_TokenTaggedDecrypt(name, pw, it, salt, cc, sp);
        return { ok: r.ok, value: r.value, verified: true };
      }
      const r = await ROT500KV_Decrypt(name, pw, it, salt, cc, sp);
      return { ok: r.ok, value: r.value, verified: true };
    }

    btnEnc.addEventListener("click", async () => {
      try {
        setBusy(true);
        status("Encoding… (PBKDF2/HMAC can take a moment)");
        const t0 = performance.now();
        const enc = await doEncode();
        const t1 = performance.now();
        $("out").value = enc;

        const { mode, pw, it, salt, sp } = getParams();
        if (mode === "ROT500K") {
          const dec = await ROT500K_Decrypt(enc, pw, it, salt, sp);
          status(`Done in ${Math.round(t1 - t0)} ms. Self-check: OK`, dec === $("name").value);
        } else {
          status(`Done in ${Math.round(t1 - t0)} ms.`, true);
        }
      } catch (e) {
        console.error(e);
        status("Error: " + (e && e.message ? e.message : String(e)), false);
      } finally {
        setBusy(false);
      }
    });

    btnDec.addEventListener("click", async () => {
      try {
        setBusy(true);
        status("Decoding…");
        const t0 = performance.now();
        const r = await doDecode();
        const t1 = performance.now();

        $("out").value = r.value || "";

        if (!r.verified) {
          status(`Done in ${Math.round(t1 - t0)} ms. (No verification in ROT500K)`, true);
        } else {
          status(`Done in ${Math.round(t1 - t0)} ms. Verified: ${r.ok ? "OK" : "FAILED"}`, r.ok);
        }
      } catch (e) {
        console.error(e);
        status("Error: " + (e && e.message ? e.message : String(e)), false);
      } finally {
        setBusy(false);
      }
    });

    btnSwap.addEventListener("click", () => {
      const a = $("name").value;
      $("name").value = $("out").value;
      $("out").value = a;
      status("Swapped.");
    });

    // Tabs
    document.querySelectorAll(".tabbtn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".tabbtn").forEach(b => b.classList.remove("active"));
        document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
        btn.classList.add("active");
        document.getElementById(btn.dataset.tab).classList.add("active");
      });
    });
  })();
  </script>
</body>
</html>